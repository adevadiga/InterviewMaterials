1. String algo questions
2. Design pattern question
3. sql joins
4. Reverse linked list
5. What is the syntax for using sort to get rid of duplicates?

6. What is the difference between dependency injection and inversion control?
=>IoC is a generic term meaning rather than having the application call the methods in a framework, the framework calls implementations provided by the application.
DI is a form of IoC, where implementations are passed into an object through constructors/setters/service look-ups, which the object will 'depend' on in order to behave correctly.


Ex: bean creation, inject dependcny for bean, transaction apply etc

IoC without using DI, for example would be the Template pattern because the implementation can only be changed through sub-classing.

DI is process whereby objects define their dependencies only through constructor arguments, arguments to factory method or properties that
are set on the object instance after they are created or returned from factory method.
The container inject these dependencies after it creates the bean.
The process is inverse - the bean itself is not responsible for locating its dependencies or by direct construction of classes.





7. How to use externalization in java
8. Serialization and Externalization
9. If in EMP table I have null EMP_Name, so when we do Order by EMP_Name, than which values come first?
=>null will come last. 


brain teaser question: you have two balls and one 100-story building. What is minimum tries to figure out which floor will break the ball if a ball is dropped from that floor.  

Write the algorithm to find all possible phone numbers that can be dialed on a standard touch-tine phone keypad when the "next digit" can only be selected from the #'s that are reached by moving as a Chess Knight (over 2 & up/down 1, or over 1 & up/down 2)  

There is scenario where I have Interface X, which has been implemented with my thousands of classes. Now I want to add new method in that Interface X. So how to make the changes in minimal way to solve the problem of overridden of methods in all my classes

There is one scenario where We have 3 Producer P1,P2,P3 and 3 Consumer C1,C2,C3,. The producer produce the X1,X2,X3 in random order and put in to Queue. Now I want to consume the things like C1 consume [X1,X2,X3] same like C2 [Y1,Y2,Y3] ….where the queue contains [x1,x2,y1,x3,y2,y3….]…  How to implement this things

What should I take care when we make our own Thread Pool ?

Select Count(*) /Count(1) which is better?
=>Performance is same. The way it counts null also same.
Moreover, SELECT(1) vs SELECT(*) will NOT have any difference in INDEX usage -- most DBMS will actually optimize SELECT( n ) into SELECT(*) .
What about count(*) and count(SomeColumnName)?
=>count(*) counts NULLs and count(column) does not.


How does substring works in String?
=>public String substring(int beginIndex) {
        if (beginIndex < 0) {
            throw new StringIndexOutOfBoundsException(beginIndex);
        }
        int subLen = value.length - beginIndex;
        if (subLen < 0) {
            throw new StringIndexOutOfBoundsException(subLen);
        }
        return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);
    }
Allocates a new String that contains characters from a subarray of the character array argument.
In the new String object created its internal array will be populated with the calue from the passed array.
Java 7 it was fixed.
Java 6  Substring creates new object out of source string by taking a portion of original string



problem with double lock checking in Singleton?
=>
1.Thread A notices that the value is not initialized, so it obtains the lock and begins to initialize the value.
Due to the semantics of some programming languages, the code generated by the compiler is allowed to update the shared variable to point to a partially constructed object before A has finished performing the initialization. For example, in Java if a call to a constructor has been inlined then the shared variable may immediately be updated once the storage has been allocated but before the inlined constructor initializes the object.[5]

2. Thread B notices that the shared variable has been initialized (or so it appears), and returns its value. Because thread B believes the value is already initialized, it does not acquire the lock. If B uses the object before all of the initialization done by A is seen by B (either because A has not finished initializing it or because some of the initialized values in the object have not yet percolated to the memory B uses (cache coherence)), the program will likely crash.

One of the dangers of using double-checked locking in J2SE 1.4 (and earlier versions) is that it will often appear to work: it is not easy to distinguish between a correct implementation of the technique and one that has subtle problems. Depending on the compiler, the interleaving of threads by the scheduler and the nature of other concurrent system activity, failures resulting from an incorrect implementation of double-checked locking may only occur intermittently. Reproducing the failures can be difficult.


It has been fixed in Java 1.5. 
The volatile keyword now ensures that multiple threads handle the singleton instance correctly.
class Foo {
    private volatile Helper helper;
    public Helper getHelper() {
        Helper result = helper;
        if (result == null) {
            synchronized(this) {
                result = helper;
                if (result == null) {
                    helper = result = new Helper();
                }
            }
        }
        return result;
    }

    // other functions and members...
}




